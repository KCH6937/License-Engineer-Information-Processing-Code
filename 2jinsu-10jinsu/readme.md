# 2진수 <-> 10진수
10진수를 2진수로 바꿀 때는 소인수분해(2로 계속 나눔), 

2진수를 10진수로 바꿀 때는 자리수만큼 2의 승수를 곱해주면 된다.  
- 2진수 → 10진수 예시  
![3](https://t1.daumcdn.net/cfile/tistory/2620FD4957EC8CB22A)
- - -  
75를 2진수로 변환 
---
2진수로 변환하므로 2로 계속 나누어 준다.  

	2|75  
	2|37 . . . 1  // 나머지
	2|18 . . . 1  
	2|9  . . . 0  
	2|4  . . . 1  
	2|2  . . . 0  
	  1  . . . 0
마지막 몫인 1부터 나머지 값인 0, 0, 1, 0, 1, 1 순서로 읽으면 된다.  
결과값 : 1001011

코드 예시

```
#include<stdio.h>

int main(void)
{
	int a[8] = {0, };	// 2진수의 각 자리수를 담을 배열
	int n = 75;		// 75를 2진수로 바꿈
	int i = 0;
	
	while(i < 8)	// 배열의 크기 8(7까지)
	{
		a[i++] = n % 2;		// 75를 2로 나눈 나머지 값을 저장 -> 소인수분해의 과정
		n /= 2;		// 75를 2로 나누었으니 그 값을 나눈값을 다시 저장
	}
	
	for(i = 7; i >= 0; i--)	// 거꾸로 출력
	{
		printf("%d", a[i]);	// 배열 a[8]의 a[7]부터 a[0]까지 거꾸로 출력
							// 결과값 : 01001011
							// *제일 왼쪽의 0은 배열의 크기를 8로 잡으면서 생긴 값(무시해도 됨)
	}
}
```
- - -    
2진수 1001011를 75로 변환
---
6 5 4 3 2 1 0 -> 2의 승수를 나타낸다.  

1 0 0 1 0 1 1  

- 제일 왼쪽은 1이므로 : 1 * 2의 6승 = 64
- 제일 왼쪽에서 2번째는 0 이므로 : 0 * 2의 5승 = 0
- 제일 왼쪽에서 3번째는 0 이므로 : 0 * 2의 4승 = 0
- 제일 왼쪽에서 4번째는 1 이므로 : 1 * 2의 3승 = 8
- 제일 왼쪽에서 5번째는 0 이므로 : 0 * 2의 2승 = 0
- 제일 왼쪽에서 6번째는 1 이므로 : 1 * 2의 1승 = 2
- 제일 왼쪽에서 7번째는 1 이므로 : 1 * 2의 0승(=1) = 1  

따라서 64 + 8 + 2 + 1 = 75  
결과값 : 75

코드 예시
```
#include<stdio.h>

int main(void)
{
	int decimal = 0;	// 10진수로 변환된 값이 저장될 변수
    int binary[7] = { 1, 0, 0, 1, 0, 1, 1 };    // 1001011 순서대로 저장(10진수 75)
	int position = 0;	// 쉬프트 연산을 할 변수
	
	for (int i = 6; i >= 0; i--)	// 6부터 0까지 총 7번(= 배열의 크기)
	{
		if (binary[i] == 1)
		{
			decimal += 1 << position;	// 왼쪽 시프트(**핵심)
		}
		position++;	// 왼쪽 시프트 이동하는 칸수값 1 증가
	}
	
	printf("%d\n", decimal);	// 10진수 출력
}
```  
---
코드 디버깅  
- i = 6 일때,  
position = 0	// 왼쪽 시프트 연산(왼쪽으로 0칸 이동)  
binary[6] = 1	// if(binary[6] == 1) 참(1) 이므로 if(binary[6] == 1) 실행   
decimal = 1		// 10진수 1저장  
position++		// position값 1 증가(position = 1)

	2진수로 표현 : 0000001

- i = 5 일때,  
position = 1	// 왼쪽 시프트 연산(왼쪽으로 1칸 이동)    
binary[5] = 1	//  if(binary[5] == 1) 참(1) 이므로 if문 실행   
decimal = 3		// i = 6일때 decimal = 1 이였으므로, decimal = 3( 1 + 2(2의 1승) ) 저장    
position++		// position값 1 증가(position = 2)

	2진수로 표현 : 0000001 + 0000010 = 0000011

- i = 4 일때,  
position = 2	// 왼쪽 시프트 연산(왼쪽으로 2칸 이동)  
binary[4] = 0	// if(binary[4] == 1) 거짓(0) 이므로 if문 실행하지 않음      
position++		// position값 1 증가(position = 3)

	2진수로 표현 : 0000011

- i = 3 일때,  
position = 3	// 왼쪽 시프트 연산(왼쪽으로 3칸 이동)  
binary[3] = 1	// if(binary[3] == 1) 참(1) 이므로 if문 실행  
decimal = 3		// i = 5일때 decimal = 3 이였으므로, decimal = 11( 3 + 8(2의 3승) ) 저장   
position++		// position값 1 증가(position = 4)

	2진수로 표현 : 0000011 + 001000 = 0001011
	
- i = 2 일때,  
position = 4	// 왼쪽 시프트 연산(왼쪽으로 4칸 이동)  
binary[2] = 0	// if(binary[2] == 1) 거짓(0) 이므로 if문 실행하지 않음      
position++		// position값 1 증가(position = 5)

	2진수로 표현 : 00001011
	
- i = 1 일때,  
position = 5	// 왼쪽 시프트 연산(왼쪽으로 5칸 이동)  
binary[1] = 0	// if(binary[1] == 1) 거짓(0) 이므로 if문 실행하지 않음      
position++		// position값 1 증가(position = 6)

	2진수로 표현 : 00001011
	
- i = 0 일때,  
position = 6	// 왼쪽 시프트 연산(왼쪽으로 6칸 이동)  
binary[0] = 1	// if(binary[0] == 1) 참(1) 이므로 if문 실행  
decimal = 6		// i = 3일때 decimal = 11 이였으므로, decimal = 75( 11 + 64(2의 6승) ) 저장    
position++		// position값 1 증가(position = 7)

	2진수로 표현 : 0001011 + 1000000 = 1001011
				// i = 0 까지이므로 for문 종료
